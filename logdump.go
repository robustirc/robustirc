package main

import (
	"encoding/binary"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/google/renameio/v2"
	"github.com/hashicorp/raft"
	pb "github.com/robustirc/robustirc/internal/proto"
	"github.com/robustirc/robustirc/internal/robust"
	"github.com/stapelberg/glog"
)

func determineLastSeen(latest string) (robust.Id, error) {
	log.Printf("determining lastseen message from %s", latest)
	f, err := os.Open(latest)
	if err != nil {
		return robust.Id{}, err
	}
	defer f.Close()
	r := csv.NewReader(f)
	var lastSeen robust.Id
	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return robust.Id{}, err
		}

		before, _, ok := strings.Cut(record[0], ".")
		if !ok {
			return robust.Id{}, fmt.Errorf("malformed log entry: %q is not a robust.Id", record[0])
		}
		parsed, err := strconv.ParseUint(before, 10, 64)
		if err != nil {
			return robust.Id{}, fmt.Errorf("malformed log entry: %q is not a robust.Id", record[0])
		}
		lastSeen = robust.Id{Id: parsed}
	}
	return lastSeen, nil
}

func dumpLogToDisk1(fsm *FSM, dumpDir string) error {
	now := time.Now()
	todayDir := filepath.Join(dumpDir, now.Format("2006-01-02"))
	logfiles, err := os.ReadDir(todayDir)
	if err != nil {
		if os.IsNotExist(err) {
			if err := os.MkdirAll(todayDir, 0700); err != nil {
				return fmt.Errorf("dumping textlog: %v", err)
			}
			// fallthrough
		} else {
			return fmt.Errorf("dumping textlog: %v", err)
		}
	}

	log.Printf("dumping textlog to %s", todayDir)

	var lastSeen robust.Id
	if len(logfiles) > 0 {
		latest := logfiles[len(logfiles)-1].Name()
		lastSeen, err = determineLastSeen(filepath.Join(todayDir, latest))
		log.Printf("last seen message %d, skipping everything before", lastSeen.Id)
	}

	log.Printf("Acquiring restore lock")
	fsm.restoreMu.Lock()
	defer fsm.restoreMu.Unlock()
	log.Printf("Obtained restore lock")

	// Iterate through all IRC messages currently in the ircstore.
	first, err := fsm.ircstore.FirstIndex()
	if err != nil {
		return err
	}
	last, err := fsm.ircstore.LastIndex()
	if err != nil {
		return err
	}
	if first < 1 {
		// This can happen with new networks (no raft messages processed yet).
		return fmt.Errorf("first index of ircstore (%d) is < 1", first)
	}
	log.Printf("Filtering and writing up to %d indexes (from %d to %d)\n", last-first+1, first, last)

	destPath := filepath.Join(todayDir, now.Format(time.RFC3339)+".csv")
	out, err := renameio.NewPendingFile(destPath)
	if err != nil {
		return err
	}
	defer out.Cleanup()
	wr := csv.NewWriter(out)

	iterator := fsm.ircstore.GetBulkIterator(first, last+1)
	defer iterator.Release()
	available := iterator.First()
	for available {
		var nlog raft.Log
		if err := iterator.Error(); err != nil {
			return err
		}
		i := binary.BigEndian.Uint64(iterator.Key())
		value := iterator.Value()
		if len(value) > 0 && value[0] == 'p' {
			var p pb.RaftLog
			if err := proto.Unmarshal(value[1:], &p); err != nil {
				glog.Errorf("Skipping log entry %d because of a proto unmarshaling error: %v", i, err)
				available = iterator.Next()
				continue
			}
			nlog.Index = p.Index
			nlog.Term = p.Term
			nlog.Type = raft.LogType(p.Type)
			nlog.Data = p.Data
			nlog.Extensions = p.Extensions
			nlog.AppendedAt = p.AppendedAt.AsTime()
		} else {
			// XXX(1.0): delete this branch, ircstore uses proto
			if err := json.Unmarshal(value, &nlog); err != nil {
				glog.Errorf("Skipping log entry %d because of a JSON unmarshaling error: %v", i, err)
				available = iterator.Next()
				continue
			}
		}
		available = iterator.Next()

		if nlog.Type != raft.LogCommand {
			return fmt.Errorf("nlog.Type = %d instead of LogCommand", nlog.Type)
		}

		parsed := robust.NewMessageFromBytes(nlog.Data, robust.IdFromRaftIndex(nlog.Index))
		if parsed.Type != robust.IRCFromClient {
			continue
		}

		// check if message is more recent than lastseen
		if parsed.Id.Id <= lastSeen.Id {
			continue
		}

		// log all IRC messages and their replies
		raftId := parsed.Id.Id // unique, strictly monotonically increasing
		remoteAddr := parsed.RemoteAddr
		sessionId := parsed.Session.Id
		// parsed.Timestamp() is put into the message by the server which
		// accepts the message (no guarantees)
		rfc3339 := parsed.Timestamp().Format(time.RFC3339)
		if err := wr.Write([]string{
			strconv.FormatUint(raftId, 10) + ".0",
			remoteAddr,
			fmt.Sprintf("0x%x", sessionId),
			rfc3339,
			parsed.Data,
		}); err != nil {
			return err
		}
		if outputmsgs, ok := outputStream.Get(parsed.Id); ok {
			for _, msg := range outputmsgs {
				if err := wr.Write([]string{
					fmt.Sprintf("%d.%d", msg.Id.Id, msg.Id.Reply),
					"", // generated by RobustIRC; no remote address
					"", // generated by RobustIRC; not tied to any session
					rfc3339,
					msg.Data,
				}); err != nil {
					return err
				}
			}
		}
	}

	wr.Flush()
	if err := wr.Error(); err != nil {
		return err
	}
	if err := out.CloseAtomicallyReplace(); err != nil {
		return err
	}
	return nil
}
